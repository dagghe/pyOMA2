"""FREQUENCY DOMAIN DECOMPOSITION (FDD) ALGORITHM"""
from __future__ import annotations

import logging
import typing

import matplotlib.pyplot as plt
import pandas as pd

from pyoma2.algorithm.base import BaseAlgorithm
from pyoma2.algorithm.data.geometry import Geometry1, Geometry2
from pyoma2.algorithm.data.result import (
    EFDDResult,
    FDDResult,
)
from pyoma2.algorithm.data.run_params import (
    EFDDRunParams,
    FDDRunParams,
)
from pyoma2.functions import (
    FDD_funct,
    plot_funct,
)
from pyoma2.functions.plot_funct import (
    plt_lines,
    plt_nodes,
    plt_quiver,
    plt_surf,
    set_ax_options,
    set_view,
)
from pyoma2.plot.anim_mode import AniMode
from pyoma2.plot.Sel_from_plot import SelFromPlot

logger = logging.getLogger(__name__)


# =============================================================================
# SINGLE SETUP
# =============================================================================
# FREQUENCY DOMAIN DECOMPOSITION
# FIXME ADD REFERENCES
class FDD_algo(BaseAlgorithm[FDDRunParams, FDDResult, typing.Iterable[float]]):
    """
    Frequency Domain Decomposition (FDD) algorithm for operational modal analysis.

    This class implements the FDD algorithm, which is used to identify modal parameters
    such as natural frequencies, damping ratios, and mode shapes, from ambient vibrations.

    Attributes
    ----------
    RunParamCls : Type[FDDRunParams]
        The class for the run parameters specific to the FDD algorithm.
    ResultCls : Type[FDDResult]
        The class for the results generated by the FDD algorithm.
    data : Iterable[float]
        The input data for the algorithm, typically a time series of vibration measurements.

    Methods
    -------
    run() -> FDDResult
        Executes the FDD algorithm on the provided data, returning the frequency domain decomposition results.
    mpe(...)
        Performs Modal Parameter Estimation (MPE) on selected frequencies from the FDD results.
    mpe_fromPlot(...)
        Performs MPE using an interactive plot for selecting frequencies from the FDD results.
    plot_CMIF(...)
        Plots the Complex Mode Indication Function (CMIF) for the results.
    plot_mode_g1(...)
        Plots the mode shapes for a specified mode number using Geometry 1 setup.
    plot_mode_g2(...)
        Plots the mode shapes for a specified mode number using Geometry 2 setup.
    anim_mode_g2(...)
        Creates an animation of the mode shapes for a specified mode number using Geometry 2 setup.

    References
    ----------
    For detailed information on the Frequency Domain Decomposition (FDD) algorithm, please refer to:
    [Reference needed here - replace with actual reference]

    Notes
    -----
    The implementation assumes the input data is in the form of a time series of vibration measurements.
    The algorithm is part of the operational modal analysis methods used in structural dynamics.
    """

    RunParamCls = FDDRunParams
    ResultCls = FDDResult

    def run(self) -> FDDResult:
        """
        Executes the Frequency Domain Decomposition algorithm on the input data.

        This method computes the spectral density matrix from the input time series data and extracts
        its singular values and vectors.

        Returns
        -------
        FDDResult
            An object containing the frequency spectrum, spectral density matrix,
            and its singular values and vectors.
        """
        super()._pre_run()
        Y = self.data.T
        nxseg = self.run_params.nxseg
        method = self.run_params.method_SD
        pov = self.run_params.pov
        # self.run_params.df = 1 / dt / nxseg

        freq, Sy = FDD_funct.SD_Est(Y, Y, self.dt, nxseg, method=method, pov=pov)
        Sval, Svec = FDD_funct.SD_svalsvec(Sy)

        # Return results
        return self.ResultCls(
            freq=freq,
            Sy=Sy,
            S_val=Sval,
            S_vec=Svec,
        )

    def mpe(self, sel_freq: typing.List[float], DF: float = 0.1) -> typing.Any:
        """
        Performs Modal Parameter Estimation (MPE) on selected frequencies.

        This method estimates the modal parameters such as natural frequencies and mode shapes
        from the specified frequencies.

        Parameters
        ----------
        sel_freq : List[float]
            List of frequencies at which modal parameters are estimated.
        DF : float, optional
            Frequency resolution for estimation, by default 0.1.

        Returns
        -------
        None
            Updates the results in the FDDResult object associated with the algorithm instance.
        """
        super().mpe(sel_freq=sel_freq, DF=DF)

        self.run_params.sel_freq = sel_freq
        self.run_params.DF = DF
        Sy = self.result.Sy
        freq = self.result.freq

        # Get Modal Parameters
        Fn_FDD, Phi_FDD = FDD_funct.FDD_MPE(Sy, freq, sel_freq, DF=DF)

        # Save results
        self.result.Fn = Fn_FDD
        self.result.Phi = Phi_FDD

    def mpe_fromPlot(
        self, freqlim: typing.Optional[tuple[float, float]] = None, DF: float = 0.1
    ) -> typing.Any:
        """
        Extracts modal parameters from selected frequencies using an interactive plot.

        This method allows interactive selection of frequencies from a plot and performs MPE
        on those frequencies.

        Parameters
        ----------
        freqlim : Optional[tuple[float, float]], optional
            Frequency range for the interactive plot, by default None.
        DF : float, optional
            Frequency resolution for estimation, by default 0.1.

        Returns
        -------
        None
            Updates the results in the FDDResult object associated with the algorithm instance.
        """
        super().mpe_fromPlot(freqlim=freqlim)

        Sy = self.result.Sy
        freq = self.result.freq

        self.run_params.DF = DF

        # chiamare plot interattivo
        SFP = SelFromPlot(algo=self, freqlim=freqlim, plot="FDD")
        sel_freq = SFP.result[0]

        # e poi estrarre risultati
        Fn_FDD, Phi_FDD = FDD_funct.FDD_MPE(Sy, freq, sel_freq, DF=DF)

        # Save results
        self.result.Fn = Fn_FDD
        self.result.Phi = Phi_FDD

    def plot_CMIF(
        self,
        freqlim: typing.Optional[tuple[float, float]] = None,
        nSv: typing.Optional[int] = "all",
    ) -> typing.Any:
        """
        Plots the Complex Mode Indication Function (CMIF).

        The CMIF plot is used to identify the presence of modes in the frequency domain data.

        Parameters
        ----------
        freqlim : Optional[tuple[float, float]], optional
            Frequency range for the CMIF plot, by default None.
        nSv : Optional[int], optional
            Number of singular values to include in the plot, by default 'all'.

        Returns
        -------
        matplotlib.figure.Figure
            A figure object containing the CMIF plot.
        """
        if not self.result:
            raise ValueError("Run algorithm first")
        fig, ax = plot_funct.CMIF_plot(
            S_val=self.result.S_val, freq=self.result.freq, freqlim=freqlim, nSv=nSv
        )
        return fig, ax

    def plot_mode_g1(
        self,
        Geo1: Geometry1,
        mode_numb: int,
        scaleF: int = 1,
        view: typing.Literal["3D", "xy", "xz", "yz", "x", "y", "z"] = "3D",
        remove_fill: bool = True,
        remove_grid: bool = True,
        remove_axis: bool = True,
    ) -> typing.Any:
        """
        Plots mode shapes for a specified mode number using the Geometry 1 setup.

        Parameters
        ----------
        Geo1 : Geometry1
            Geometry1 setup object containing sensor locations and directions.
        mode_numb : int
            Mode number to plot.
        scaleF : int, optional
            Scale factor for mode shape visualization, by default 1.
        view, remove_fill, remove_grid, remove_axis : optional
            Additional parameters for plot customization.

        Returns
        -------
        matplotlib.figure.Figure
            A figure object showing the mode shape.
        """

        if self.result.Fn is None:
            raise ValueError("Run algorithm first")

        # Select the (real) mode shape
        phi = self.result.Phi[:, int(mode_numb - 1)].real
        fn = self.result.Fn[int(mode_numb - 1)]

        fig = plt.figure(figsize=(8, 8), tight_layout=True)
        ax = fig.add_subplot(111, projection="3d")

        # set title
        ax.set_title(f"Mode nr. {mode_numb}, $f_n$={fn:.3f}Hz")

        # plot sensors' nodes
        sens_coord = Geo1.sens_coord[["x", "y", "z"]].to_numpy()
        plt_nodes(ax, sens_coord, color="red")

        # plot Mode shape
        plt_quiver(
            ax,
            sens_coord,
            Geo1.sens_dir * phi.reshape(-1, 1),
            scaleF=scaleF,
            #            names=Geo1.sens_names,
        )

        # Check that BG nodes are defined
        if Geo1.bg_nodes is not None:
            # if True plot
            plt_nodes(ax, Geo1.bg_nodes, color="gray", alpha=0.5)
            # Check that BG lines are defined
            if Geo1.bg_lines is not None:
                # if True plot
                plt_lines(ax, Geo1.bg_nodes, Geo1.bg_lines, color="gray", alpha=0.5)
            if Geo1.bg_surf is not None:
                # if True plot
                plt_surf(ax, Geo1.bg_nodes, Geo1.bg_surf, alpha=0.1)

        # check for sens_lines
        if Geo1.sens_lines is not None:
            # if True plot
            plt_lines(ax, sens_coord, Geo1.sens_lines, color="red")

        # Set ax options
        set_ax_options(
            ax,
            bg_color="w",
            remove_fill=remove_fill,
            remove_grid=remove_grid,
            remove_axis=remove_axis,
        )

        # Set view
        set_view(ax, view=view)
        return fig, ax

    def plot_mode_g2(
        self,
        Geo2: Geometry2,
        mode_numb: typing.Optional[int],
        scaleF: int = 1,
        view: typing.Literal["3D", "xy", "xz", "yz", "x", "y", "z"] = "3D",
        remove_fill: bool = True,
        remove_grid: bool = True,
        remove_axis: bool = True,
        *args,
        **kwargs,
    ) -> typing.Any:
        """
        Plots mode shapes for a specified mode number using the Geometry 2 setup.

        Parameters
        ----------
        Geo2 : Geometry2
            Geometry2 setup object containing sensor locations and directions.
        mode_numb : Optional[int]
            Mode number to plot, plots all modes if None.
        scaleF : int, optional
            Scale factor for mode shape visualization, by default 1.
        view, remove_fill, remove_grid, remove_axis : optional
            Additional parameters for plot customization.

        Returns
        -------
        matplotlib.figure.Figure
            A figure object showing the mode shape.
        """
        if self.result.Fn is None:
            raise ValueError("Run algorithm first")

        # Select the (real) mode shape
        fn = self.result.Fn[int(mode_numb - 1)]
        phi = self.result.Phi[:, int(mode_numb - 1)].real * scaleF
        # create mode shape dataframe
        df_phi = pd.DataFrame(
            {"sName": Geo2.sens_names, "Phi": phi},
        )
        mapping = dict(zip(df_phi["sName"], df_phi["Phi"]))
        # reshape the mode shape dataframe to fit the pts coord
        df_phi_map = Geo2.sens_map.replace(mapping).astype(float)
        # add together coordinates and mode shape displacement
        newpoints = Geo2.pts_coord.add(df_phi_map * Geo2.sens_sign, fill_value=0)
        # extract only the displacement array
        newpoints = newpoints.to_numpy()[:, 1:]

        # create fig and ax
        fig = plt.figure(figsize=(8, 8), tight_layout=True)
        ax = fig.add_subplot(111, projection="3d")

        # set title
        ax.set_title(f"Mode nr. {mode_numb}, $f_n$={fn:.3f}Hz")

        # Check that BG nodes are defined
        if Geo2.bg_nodes is not None:
            # if True plot
            plot_funct.plt_nodes(ax, Geo2.bg_nodes, color="gray", alpha=0.5)
            # Check that BG lines are defined
            if Geo2.bg_lines is not None:
                # if True plot
                plot_funct.plt_lines(
                    ax, Geo2.bg_nodes, Geo2.bg_lines, color="gray", alpha=0.5
                )
            if Geo2.bg_surf is not None:
                # if True plot
                plot_funct.plt_surf(ax, Geo2.bg_nodes, Geo2.bg_surf, alpha=0.1)
        # PLOT MODE SHAPE
        plot_funct.plt_nodes(ax, newpoints, color="red")
        # check for sens_lines
        if Geo2.sens_lines is not None:
            # if True plot
            plot_funct.plt_lines(ax, newpoints, Geo2.sens_lines, color="red")

        # Set ax options
        plot_funct.set_ax_options(
            ax,
            bg_color="w",
            remove_fill=remove_fill,
            remove_grid=remove_grid,
            remove_axis=remove_axis,
        )

        # Set view
        plot_funct.set_view(ax, view=view)

        return fig, ax

    def anim_mode_g2(
        self,
        Geo2: Geometry2,
        mode_numb: typing.Optional[int],
        scaleF: int = 1,
        view: typing.Literal["3D", "xy", "xz", "yz", "x", "y", "z"] = "3D",
        remove_fill: bool = True,
        remove_grid: bool = True,
        remove_axis: bool = True,
        saveGIF: bool = False,
        *args,
        **kwargs,
    ) -> typing.Any:
        """
        Creates an animation of mode shapes for a specified mode number using Geometry 2.

        Parameters
        ----------
        Geo2 : Geometry2
            Geometry2 setup object for the animation.
        mode_numb : Optional[int]
            Mode number to animate, default behavior if None.
        scaleF : int, optional
            Scale factor for mode shape visualization, by default 1.
        view, remove_fill, remove_grid, remove_axis, saveGIF : optional
            Additional parameters for animation customization.

        Returns
        -------
        None
            Produces an animation of the mode shapes.
        """
        if self.result.Fn is None:
            raise ValueError("Run algorithm first")

        Res = self.result
        logger.debug("Running Anim Mode FDD")
        AniMode(
            Geo=Geo2,
            Res=Res,
            mode_numb=mode_numb,
            scaleF=scaleF,
            view=view,
            remove_axis=remove_axis,
            remove_fill=remove_fill,
            remove_grid=remove_grid,
            saveGIF=saveGIF,
        )
        logger.debug("...end AniMode FDD...")


# ------------------------------------------------------------------------------
# ENHANCED FREQUENCY DOMAIN DECOMPOSITION EFDD
# FIXME ADD REFERENCE
class EFDD_algo(FDD_algo[EFDDRunParams, EFDDResult, typing.Iterable[float]]):
    """
    Enhanced Frequency Domain Decomposition (EFDD) Algorithm.

    This class implements the EFDD algorithm, an extension of the basic
    Frequency Domain Decomposition (FDD) method (add reference).

    Attributes
    ----------
    method : typing.Literal["EFDD", "FSDD"]
        The method type, set to "EFDD" for this class.
    RunParamCls : EFDDRunParams
        Class for run parameters specific to the EFDD algorithm.
    ResultCls : EFDDResult
        Class for storing results obtained from the EFDD algorithm.

    Methods
    -------
    mpe(...)
        Performs Modal Parameter Estimation (MPE) for selected frequencies.
    mpe_fromPlot(...)
        Interactive MPE using plots to select frequencies for EFDD analysis.
    plot_FIT(...)
        Generates a Frequency domain Identification (FIT) plot for EFDD results.

    Notes
    -----
    - The class inherits from `FDD_algo` and provides specialized implementations
    for EFDD-specific methods."""

    method: typing.Literal["EFDD", "FSDD"] = "EFDD"

    RunParamCls = EFDDRunParams
    ResultCls = EFDDResult

    def mpe(
        self,
        sel_freq: typing.List[float],
        DF1: float = 0.1,
        DF2: float = 1.0,
        cm: int = 1,
        MAClim: float = 0.85,
        sppk: int = 3,
        npmax: int = 20,
    ) -> typing.Any:
        """
        Executes the Enhanced Frequency Domain Decomposition (EFDD) algorithm for modal parameter estimation.

        Parameters
        ----------
        sel_freq : List[float]
            Selected frequencies for modal parameter estimation.
        DF1 : float, optional
            Frequency resolution for the first stage of EFDD, default is 0.1.
        DF2 : float, optional
            Frequency resolution for the second stage of EFDD, default is 1.0.
        cm : int, optional
            Number of closely spaced modes, default is 1.
        MAClim : float, optional
            Minimum acceptable Modal Assurance Criterion value, default is 0.85.
        sppk : int, optional
            Number of peaks to skip for the fit, default is 3.
        npmax : int, optional
            Maximum number of peaks to use in the fit, default is 20.

        Returns
        -------
        None
            Updates the EFDDResult object with modal parameters.
        """
        # Save run parameters
        self.run_params.sel_freq = sel_freq
        self.run_params.DF1 = DF1
        self.run_params.DF2 = DF2
        self.run_params.cm = cm
        self.run_params.MAClim = MAClim
        self.run_params.sppk = sppk
        self.run_params.npmax = npmax

        # Extract modal results
        Fn_FDD, Xi_FDD, Phi_FDD, forPlot = FDD_funct.EFDD_MPE(
            self.result.Sy,
            self.result.freq,
            self.dt,
            sel_freq,
            self.run_params.method_SD,
            method=self.method,
            DF1=DF1,
            DF2=DF2,
            cm=cm,
            MAClim=MAClim,
            sppk=sppk,
            npmax=npmax,
        )

        # Save results
        self.result.Fn = Fn_FDD.reshape(-1)
        self.result.Xi = Xi_FDD.reshape(-1)
        self.result.Phi = Phi_FDD
        self.result.forPlot = forPlot

    def mpe_fromPlot(
        self,
        DF1: float = 0.1,
        DF2: float = 1.0,
        cm: int = 1,
        MAClim: float = 0.85,
        sppk: int = 3,
        npmax: int = 20,
        freqlim: typing.Optional[tuple[float, float]] = None,
    ) -> typing.Any:
        """
        Performs Interactive Modal Parameter Estimation (MPE) using plots for the EFDD method.

        Parameters
        ----------
        DF1 : float, optional
            Frequency resolution for the first stage of EFDD, default is 0.1.
        DF2 : float, optional
            Frequency resolution for the second stage of EFDD, default is 1.0.
        cm : int, optional
            Number of clusters for mode separation, default is 1.
        MAClim : float, optional
            Minimum acceptable MAC value, default is 0.85.
        sppk : int, optional
            Number of spectral peaks to consider, default is 3.
        npmax : int, optional
            Maximum number of peaks, default is 20.
        freqlim : Optional[tuple[float, float]], optional
            Frequency limit for interactive plot, default is None.

        Returns
        -------
        None
            Updates the EFDDResult object with modal parameters selected from the plot.

        Notes
        -----
        This method allows interactive selection of frequencies from a plot for modal parameter estimation.
        """
        # Save run parameters
        self.run_params.DF1 = DF1
        self.run_params.DF2 = DF2
        self.run_params.cm = cm
        self.run_params.MAClim = MAClim
        self.run_params.sppk = sppk
        self.run_params.npmax = npmax

        # chiamare plot interattivo
        SFP = SelFromPlot(algo=self, freqlim=freqlim, plot="FDD")
        sel_freq = SFP.result[0]

        # e poi estrarre risultati
        Fn_FDD, Xi_FDD, Phi_FDD, forPlot = FDD_funct.EFDD_MPE(
            self.result.Sy,
            self.result.freq,
            self.dt,
            sel_freq,
            self.run_params.method_SD,
            method=self.method,
            DF1=DF1,
            DF2=DF2,
            cm=cm,
            MAClim=MAClim,
            sppk=sppk,
            npmax=npmax,
        )
        # Save results
        self.result.Fn = Fn_FDD.reshape(-1)
        self.result.Xi = Xi_FDD.reshape(-1)
        self.result.Phi = Phi_FDD
        self.result.forPlot = forPlot

    def plot_FIT(
        self, freqlim: typing.Optional[tuple[float, float]] = None, *args, **kwargs
    ) -> typing.Any:
        """
        Plots Frequency domain Identification (FIT) results for the EFDD method.

        Parameters
        ----------
        freqlim : Optional[tuple[float, float]], optional
            Frequency limit for the FIT plot, default is None.
        *args, **kwargs
            Additional arguments and keyword arguments for plot customization.

        Returns
        -------
        matplotlib.figure.Figure
            A figure object containing the FIT plot.

        Notes
        -----
        FIT plot is used in EFDD for visualizing the quality of modal identification.
        """
        if not self.result:
            raise ValueError("Run algorithm first")

        fig, ax = plot_funct.EFDD_FIT_plot(
            Fn=self.result.Fn,
            Xi=self.result.Xi,
            PerPlot=self.result.forPlot,
            freqlim=freqlim,
        )
        return fig, ax


# ------------------------------------------------------------------------------
# FREQUENCY SPATIAL DOMAIN DECOMPOSITION FSDD
# FIXME ADD REFERENCE
class FSDD_algo(EFDD_algo):
    """
    Frequency-Spatial Domain Decomposition (FSDD) Algorithm.

    Inherits from the Enhanced Frequency Domain Decomposition (EFDD) Algorithm class.
    This class provides the FSDD algorithm, a variant of the EFDD method (add reference).

    Attributes
    ----------
    method : typing.Literal["EFDD", "FSDD"]
        The method type, set to "FSDD" for this class.

    Notes
    -----
    - Inherits all methods and attributes from the EFDD_algo class, while focusing on the
      unique aspects of the FSDD approach.
    """

    method: str = "FSDD"


# =============================================================================
# MULTI SETUP
# =============================================================================
# FREQUENCY DOMAIN DECOMPOSITION
class FDD_algo_MS(FDD_algo[FDDRunParams, FDDResult, typing.Iterable[dict]]):
    """
    Frequency Domain Decomposition (FDD) algorithm adapted for multi-setup analysis.

    This class extends the standard FDD algorithm to support multi-setup
    operational modal analysis, which allows for merging data from multiple setups
    or experiments.

    Attributes
    ----------
    RunParamCls : Type[FDDRunParams]
        Defines the run parameters specific to the FDD algorithm.
    ResultCls : Type[FDDResult]
        Represents the class used for storing results obtained from the FDD analysis.
    data : Iterable[dict]
        The input data for the algorithm, typically a collection of vibration measurements
        from multiple setups.

    Methods
    -------
    run() -> FDDResult
        Conducts the FDD analysis on multi-setup data. It processes the spectral density
        matrices, producing singular values and vectors as results.

    Notes
    -----
    Inherits the base functionality from the standard FDD algorithm class, modifying it for
    application to datasets derived from multiple experimental setups.
    """

    RunParamCls = FDDRunParams
    ResultCls = FDDResult

    def run(self) -> FDDResult:
        """
        Executes the FDD algorithm on multi-setup data.

        This method processes the provided data to generate frequency domain decomposition results
        that include spectral density matrices, singular values, and vectors.

        Returns
        -------
        FDDResult
            An object encapsulating the results of the FDD analysis, tailored for multi-setup data.
        """
        super()._pre_run()
        Y = self.data
        nxseg = self.run_params.nxseg
        method = self.run_params.method_SD
        pov = self.run_params.pov
        # self.run_params.df = 1 / dt / nxseg

        freq, Sy = FDD_funct.SD_PreGER(Y, self.fs, nxseg=nxseg, method=method, pov=pov)
        Sval, Svec = FDD_funct.SD_svalsvec(Sy)

        # Return results
        return self.ResultCls(
            freq=freq,
            Sy=Sy,
            S_val=Sval,
            S_vec=Svec,
        )


# ------------------------------------------------------------------------------
# ENHANCED FREQUENCY DOMAIN DECOMPOSITION EFDD
class EFDD_algo_MS(EFDD_algo[EFDDRunParams, EFDDResult, typing.Iterable[dict]]):
    """
    Enhanced Frequency Domain Decomposition (EFDD) algorithm for multi-setup analysis.

    This version of the EFDD algorithm is designed to handle data from multiple setups.

    Attributes
    ----------
    method : str
        The EFDD method employed for the analysis.
    RunParamCls : EFDDRunParams
        Represents the class for specifying run parameters unique to the EFDD algorithm.
    ResultCls : EFDDResult
        The class used for storing the results obtained from the EFDD analysis.
    data : Iterable[dict]
        The input data.

    Methods
    -------
    run() -> FDDResult
        Conducts the EFDD algorithm on multi-setup data, yielding advanced modal parameters,
        such as natural frequencies, damping ratios, and mode shapes.

    Notes
    -----
    This class inherits and enhances the standard EFDD algorithm's functionality, adapting
    it for datasets derived from multiple experimental setups.
    """

    method = "EFDD"
    RunParamCls = EFDDRunParams
    ResultCls = EFDDResult

    def run(self) -> FDDResult:
        """
        Executes the EFDD algorithm on the input data.

        Returns
        -------
        FDDResult
            An object containing the results of the analysis."""
        super()._pre_run()
        Y = self.data
        nxseg = self.run_params.nxseg
        method = self.run_params.method_SD
        pov = self.run_params.pov
        # self.run_params.df = 1 / dt / nxseg

        freq, Sy = FDD_funct.SD_PreGER(Y, self.fs, nxseg=nxseg, method=method, pov=pov)
        Sval, Svec = FDD_funct.SD_svalsvec(Sy)

        # Return results
        return self.ResultCls(
            freq=freq,
            Sy=Sy,
            S_val=Sval,
            S_vec=Svec,
        )
