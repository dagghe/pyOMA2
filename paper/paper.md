---
title: 'pyOMA2: A Python module for conducting operational modal analysis'
tags:
  - Python
  - operational modal analysis
  - dynamics of structures
  - system identification
  - ambient vibrations
authors:
  - name: Dag P. Pasca
    orcid: 0000-0002-3830-2835
    corresponding: true
    affiliation: "1"
  - name: Diego Federico Margoni
    affiliation: 2
affiliations:
 - name: Norsk Treteknisk Institutt, Oslo, Norway
   index: 1
 - name: Politecnico di Torino, Italy
   index: 2

date: 12 September 2024
bibliography: paper.bib
---

# Summary

Operational Modal Analysis (OMA) has garnered considerable attention from
the engineering community in recent years and has established itself as
the preferred method for estimating the modal properties of structures in
Structural Health Monitoring (SHM), particularly in civil engineering.
The key advantage of OMA over Experimental Modal Analysis (EMA) is its
ability to derive modal parameters solely from output measurements taken
during the structure's normal operation. This makes OMA a more practical
and efficient approach, as opposed to the traditional EMA, which requires
both input and output data.

# Statement of need
`pyOMA2` is the latest and improved version of the pyOMA module, a Python
library specifically designed for conducting operational modal analysis.
It fully utilises Python's object-oriented capabilities to offer a
comprehensive suite of tools for performing OMA.

The module supports both single and multi-setup data measurements, enabling
users to handle multiple acquisitions that combine reference and roving
sensors. It is user-friendly and provides a range of tools for pre-processing
and visualising data. A key enhancement is the introduction of interactive
plots, allowing users to select the desired modes directly from
algorithm-generated graphs. Additionally, a new feature enables users to
define the geometry of tested structures, facilitating the visualisation
of mode shapes.

The following algorithm are included in the module:
- Frequency domain decomposition (FDD);
- Enhanced frequency domain decomposition (EFDD);
- Frequency spatial domain decomposition (FSDD);
- Reference based covariance driven stochastic subspace identification (SSIcov);
- Reference based data driven stochastic subspace identification (SSIdat);
- Poly-reference Least Square Frequency Domain (pLSCF);

For the readers seeking a more comprehensive understanding of the algorithms
and the underlying theory, a wealth of literature is available for consultation.
Key references include works by Brincker
[@brincker2001modal;@brincker2015introduction;@brincker2001damping],
Zhang [@zhang2010frequency], Peeters [@peeters2004polymax;@peeters1999reference],
Van Overschee and De Moor [@van2012subspace], Reynders [@reynders2012system],
Rainieri and Fabbrocino [@rainieri2014operational], Amador [@amador2021robust],
DÃ¶hler [@dohler2011subspace,dohler2013efficient,dohler2013uncertainty], and others.

The module's reliability and applicability for research purposes have been
demonstrated by the authors through various studies, such as
[@alaggio2021two;@aloisio2020dynamic;@simoncelli2023intensity].
Additionally, the module has gained traction within the research community,
as evidenced by its use in studies by
[@saharan2023convolutional;@croce2023towards;@talebi2023interoperability;@abuodeh2023examining], and others.

# Module's structure.
The module is structured into three primary levels:
1. At the first level are the `setup` classes. Users instantiate these classes by providing a data array and the sampling frequency for a single setup scenario, or a list of data arrays and their respective sampling frequencies, and reference indices, for a multi-setup scenario.
2. The second level comprises the `algorithms` classes. Users can instantiate the algorithms they wish to run and then add them to the setup class.
3. The third level contains the `support` classes, which serve as auxiliary components to the first two levels. This level includes various specialized classes:
    * `result` classes, where outcomes are stored.
    * `geometry` classes, for storing geometric data.
    * `run_param` classes, where parameters used for running the algorithms are kept.
    * Dedicated classes for animating mode shapes and interacting with plots generated by the algorithm classes.

In addition to the levels depicted in the figure, there is a further
level not shown, comprised of the set of functions internally called
by the class methods. Many of these functions represent an updated
version of those available in our previous release, `pyOMA`.

![Schematic organisation of the module showing inheritance between classes](../docs/img/info.svg)

# Documentation
A comprehensive documentation for `pyOMA2`, including examples, is available at
[https://pyoma.readthedocs.io/en/main/](https://pyoma.readthedocs.io/en/main/).


# Acknowledgements

We acknowledge contributions from Angelo Aloisio and Marco Martino Rosso.

# References
